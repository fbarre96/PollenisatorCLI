from utils.utils import command, cls_commands, print_error
from utils.utils import main_help, isIp, isNetworkIp, isDomain
from utils.completer import IMCompleter
from core.Modules.module import Module
from prompt_toolkit.formatted_text import FormattedText
from core.apiclient import APIClient
from core.Models.Command import Command
from core.Models.Wave import Wave
from core.Models.Scope import Scope
from core.Models.Ip import Ip
from core.Models.Port import Port
from core.Views.CommandView import CommandView
from core.Views.WaveView import WaveView
from core.Views.ScopeView import ScopeView
from core.Views.IpView import IpView
from core.Views.PortView import PortView
from core.Views.ViewElement import ViewElement
@cls_commands
class Pentest(Module):
    def __init__(self, parent_context, prompt_session):
        super().__init__('Pentest', parent_context, "Pentesting mode.", 'Pentesting <placeholder>', IMCompleter(self), prompt_session)
        #TODO add modules
        """Modules
        =========
        Commands
        Tags
        Dashboard
        Summary
        Scan
        Report
        Settings
        Terminal
        """
    @command
    def reset_running_tools(self):
        """
        Usage : reset_running_tools
        Description : Reset all tools running to a ready state. This is useful if a command was running on a worker and the auto scanning was interrupted.
        """
        # test all the cases if datef is defined or not.
        # Normally, only the first one is necessary
        from core.Models.Tool import Tool
        tools = Tool.fetchObjects({"datef": "None", "scanner_ip": {"$ne": "None"}})
        for tool in tools:
            tool.markAsNotDone()
        tools = Tool.fetchObjects({"datef": "None", "dated": {"$ne": "None"}})
        for tool in tools:
            tool.markAsNotDone()
        tools = Tool.fetchObjects(
            {"datef": {"$exists": False}, "dated": {"$ne": "None"}})
        for tool in tools:
            tool.markAsNotDone()
        tools = Tool.fetchObjects(
            {"datef": {"$exists": False}, "scanner_ip": {"$ne": "None"}})
        for tool in tools:
            tool.markAsNotDone()

    @command
    def ls(self, object_type):
        """Usage: ls commands|waves|scopes|ips

        Description: List all objects from the given type
        """
        apiclient = APIClient.getInstance()
        if object_type == "commands":
            commands = Command.fetchObjects({}, apiclient.getCurrentPentest())
            for command in commands:
                print(command.getDetailedString())
            return True
        elif object_type == "waves":
            waves = Wave.fetchObjects({})
            for wave in waves:
                print(wave.getDetailedString())
            return True
        elif object_type == "scopes":
            scopes = Scope.fetchObjects({})
            for scope in scopes:
                print(ViewElement.colorWithTags(scope.getTags(), scope.getDetailedString()))
            return True
        elif object_type == "ips":
            ips = Ip.fetchObjects({})
            for ip in ips:
                print(ViewElement.colorWithTags(ip.getTags(), ip.getDetailedString()))
            return True
        return False
    
    def identifyPentestObjectsFromString(self, obj_str):
        if isIp(obj_str) or isDomain(obj_str):
            return IpView, [x for x in Ip.fetchObjects({"ip":obj_str})]
        if isNetworkIp(obj_str) or isDomain(obj_str):
            return ScopeView, [x for x in Scope.fetchObjects({"scope":obj_str})]
        #test for ip:port/Proto
        parts = obj_str.split(":")
        if len(parts) == 2 and (isIp(parts[0]) or isDomain(parts[0])):
            port_parts = parts[1].split("/")
            if len(port_parts) == 1:
                return PortView, [x for x in Port.fetchObjects({"ip":parts[0], "port":port_parts[0], "proto":"tcp"})]
            else:
                return PortView, [x for x in Port.fetchObject({"ip":parts[0], "port":port_parts[0], "proto":port_parts[1]}) ]
        waves = [x for x in Wave.fetchObjects({"wave": obj_str})]
        if waves:
            return WaveView, waves
        commands = [x for x in Command.fetchObjects({"name":obj_str})]
        if commands:
            return CommandView, commands
        return None, []

    @command
    def info(self, object_title):
        """Usage: info <object_title>|commands|waves|scopes|ips

        Description: Show informations for the given object title:
        
        Arguments:
            object_title: a string to identify an object. or a class of objects as a plural
            * commands|waves|scopes|ips : equivalent to ls call
            * Scope : a network ip as x.x.x.x/y or a domain. Add "<wave_name>:" in front of scope if  many waves registered it
            * Ip: An ip or a domain
            * Port: an ip:port[/proto]
            * Wave: a wave name
            * Command: a command name
        """
        if self.ls(object_title):
            return # Ls worked
        cls, objects_matching = self.identifyPentestObjectsFromString(object_title)
        if cls is not None:
            cls.print_info(objects_matching) # Todo create in eac object view a print_info method
        else:
            print(f"No info regarding {object_title}")
    @command
    def open(self, object_title):
        """Usage: open <object_title>

        Description: open object module:
        
        Arguments:
            object_title: a string to identify an object.
            * Scope : a network ip as x.x.x.x/y or a domain. Add "<wave_name>:" in front of scope if  many waves registered it
            * Ip: An ip or a domain
            * Port: an ip:port[/proto]
            * Wave: a wave name
            * Command: a command name
        """
        # will swap context for 
        
        cls, objects_matching = self.identifyPentestObjectsFromString(object_title)
        if cls is not None:
            if len(objects_matching) == 1:
                self.set_context(cls(objects_matching[0]))
            else:
                cls.print_info(objects_matching)
        else:
            print_error(f"No object found matching this {object_title}")

    @command
    def query(self, search_query):
        """Usage: query <search_query>

        Description : Print a list of object title matching the query

        Arguments:
            search_query: A python like condition with:
                            - condition operators (==, !=, >, < , <=, >=, not in, in, regex) 
                            - boolean logic (and, or, not)
            Search examples in match (python condition):
            type == "port"
            type == "port" and port == 443
            type == "port" and port regex "443$"
            type == "port" and (port == 80 or port == 443)
            type == "port" and port != 443
            type == "port" and port != 443 and port != 80
            type == "defect"
            type == "defect" and "Foo" in title
            type == "ip" and ip regex "[A-Za-z]"
            type == "ip" and ip regex "^1\.2"
            type == "tool" and "done" in status
            type == "tool" and "done" not in status
            type == "tool" and "ready" in status
            type == "ip" and infos.key == "ABC" 
        """
        pass #TODO
    
    def getOptionsForCmd(self, cmd, cmd_args, complete_event):
        """Returns a list of valid options for the given cmd
        """  
        apiclient = APIClient.getInstance()
        if cmd == "help":
            return [""]+self._cmd_list
        elif cmd == "ls":
            return ["commands", "waves", "scopes", "ips"]
        elif cmd in ["info", "edit"]:
            return [] #TODO
        elif cmd == "query":
            return [] # TODO
        return []