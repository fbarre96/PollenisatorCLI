from utils.utils import command, cls_commands, print_error, print_formatted
from utils.utils import main_help, isIp, isNetworkIp, isDomain
from utils.completer import IMCompleter
from core.Modules.module import Module
from core.Modules.scans import Scans
from core.Modules.report import Report
from core.FormModules.settingsForms import PentestSettings
import re
import os
from prompt_toolkit import prompt
from prompt_toolkit.formatted_text import FormattedText
from core.apiclient import APIClient
from core.settings import Settings
from core.Models.Command import Command
from core.Models.Wave import Wave
from core.Models.Scope import Scope
from core.Models.Ip import Ip
from core.Models.Port import Port
from core.Models.Defect import Defect
from core.Models.Tool import Tool
from core.Controllers.CommandController import CommandController
from core.Controllers.IpController import IpController
from core.Controllers.PortController import PortController
from core.Controllers.ScopeController import ScopeController
from core.Controllers.WaveController import WaveController

from core.Views.CommandView import CommandView
from core.Views.WaveView import WaveView
from core.Views.ScopeView import ScopeView
from core.Views.IpView import IpView
from core.Views.PortView import PortView
from core.Views.DefectView import DefectView
from core.Views.ToolView import ToolView
from core.Views.ViewElement import ViewElement
from core.Views.Dashboard import Dashboard
from prompt_toolkit.shortcuts import ProgressBar
from prompt_toolkit.document import Document
from prompt_toolkit.completion import Completion
from prompt_toolkit import print_formatted_text, HTML
import time
from AutoScanWorker import executeCommand

@cls_commands
class Pentest(Module):
    def __init__(self, parent_context, prompt_session):
        super().__init__('Pentest', parent_context, "Pentesting mode.", 'Pentesting <placeholder>', IMCompleter(self), prompt_session)
        #TODO add modules
        """Modules
        =========
        Tags
        Dashboard
        Summary
        Scan
        Report
        Settings
        Terminal 
        """
    @command
    def scans(self):
        """Usage : scans
        Description : open the scan module
        """
        self.set_context(Scans(self, self.prompt_session))

    @command
    def pentest_settings(self):
        """Usage : settings
        Description : open the settings of this pentest
        """
        self.set_context(PentestSettings(self, self.prompt_session))

    @command
    def dashboard(self):
        """Usage : dashboard
        Description : print dahsboards for this pentest
        """
        dashboards = {"Services per hosts":Dashboard.printServicesPerHosts,
                      "Top ports": Dashboard.printTopPorts,
                      "Tools state": Dashboard.printToolsState}
        response = None
        while response != 0:
            print_formatted("Choose a dashboard to open:")
            for i,dashboard in enumerate(dashboards.keys()):
                print_formatted(f"{i+1}. {dashboard}")
            print_formatted("0. exit")
            response = prompt("Choice : ")
            try:
                response = int(response)
                if response > len(dashboards):
                    response = None
            except ValueError:
                response = None
            if response is not None:
                if response-1 >= 0 and response-1 < len(dashboards.keys()):
                    dashboards[list(dashboards.keys())[response-1]]()
    
    @command
    def report(self):
        """Usage : report
        Description : Generate reports with registered defects and add some manually
        """
        self.set_context(Report(self, self.prompt_session))
        

    @command
    def exec(self, *args):
        """Usage: exec <command line to another tool>
        Description: Will execute the given command line and will try to automatically import it if the binary is configured in server config/tools.d
        """
        cmdArgs = " ".join(args)
        cmdName = os.path.splitext(os.path.basename(args[0]))[0]
        cmdName +="::"+str(time.time()).replace(" ","-")
        wave = Wave().initialize("Custom commands")
        wave.addInDb()
        tool = Tool()
        tool.initialize(cmdName, "Custom commands", None, None, None, None, "wave", text=cmdArgs, dated="None", datef="None", scanner_ip="localhost", infos={"args":" ".join(args)})
        res, iid = tool.addInDb()
        if res:
            res, msg = executeCommand(APIClient.getInstance().getCurrentPentest(), str(iid), "auto-detect")
            if not res:
                print_error(msg)
        return

    @command
    def reset_running_tools(self):
        """
        Usage : reset_running_tools
        Description : Reset all tools running to a ready state. This is useful if a command was running on a worker and the auto scanning was interrupted.
        """
        # test all the cases if datef is defined or not.
        # Normally, only the first one is necessary
        from core.Models.Tool import Tool
        tools = Tool.fetchObjects({"datef": "None", "scanner_ip": {"$ne": "None"}})
        for tool in tools:
            tool.markAsNotDone()
        tools = Tool.fetchObjects({"datef": "None", "dated": {"$ne": "None"}})
        for tool in tools:
            tool.markAsNotDone()
        tools = Tool.fetchObjects(
            {"datef": {"$exists": False}, "dated": {"$ne": "None"}})
        for tool in tools:
            tool.markAsNotDone()
        tools = Tool.fetchObjects(
            {"datef": {"$exists": False}, "scanner_ip": {"$ne": "None"}})
        for tool in tools:
            tool.markAsNotDone()
    
    @command
    def upload(self, path, plugin_name):
        """Usage: upload <path/to/tool_file/or/directory> <plugin_name>

        Description: Upload the given file or all files in directory to be integrated on the server side using plugin-name
        """
        files = []
        if os.path.isdir(path):
            # r=root, d=directories, f = files
            for r, _d, f in os.walk(path):
                for fil in f:
                    files.append(os.path.join(r, fil))
        else:
            files.append(path)
        #dialog = ChildDialogProgress(self.parent, "Importing files", "Importing "+str(
        #    len(files)) + " files. Please wait for a few seconds.", 200, "determinate")
        #dialog.show(len(files))
        # LOOP ON FOLDER FILES
        results = {}
        apiclient = APIClient.getInstance()
        with ProgressBar() as pb:
            for f_i, file_path in pb(enumerate(files)):
                results = apiclient.importExistingResultFile(file_path, plugin_name)
            #dialog.update(f_i)
        #dialog.destroy()
        # DISPLAY RESULTS
        presResults = ""
        filesIgnored = 0
        for key, value in results.items():
            presResults += str(value) + " " + str(key)+".\n"
            if key == "Ignored":
                filesIgnored += 1
        if filesIgnored > 0:
            print_formatted(presResults, "warning")
        else:
            print_formatted(presResults, "valid")
       


    @command
    def ls(self, object_type):
        """Usage: ls commands|waves|scopes|ips|defects

        Description: List all objects from the given type
        """
        apiclient = APIClient.getInstance()
        if object_type == "commands":
            commands = Command.fetchObjects({}, apiclient.getCurrentPentest())
            for command in commands:
                print_formatted_text(command.getDetailedString())
            return True
        elif object_type == "waves":
            waves = Wave.fetchObjects({})
            for wave in waves:
                print_formatted_text(wave.getDetailedString())
            return True
        elif object_type == "scopes":
            scopes = Scope.fetchObjects({})
            for scope in scopes:
                print_formatted_text(ViewElement.colorWithTags(scope.getTags(), scope.getDetailedString()))
            return True
        elif object_type == "ips":
            ips = Ip.fetchObjects({})
            for ip in ips:
                print_formatted_text(ViewElement.colorWithTags(ip.getTags(), ip.getDetailedString()))
            return True
        elif object_type == "defects":
            defects = Defect.fetchObjects({})
            for defect in defects:
                print_formatted_text(ViewElement.colorWithTags(defect.getTags(), defect.getDetailedString()))
            return True
        return False
    
    def identifyPentestObjectsFromString(self, obj_str):
        if isIp(obj_str):
            return IpView, [IpController(x) for x in Ip.fetchObjects({"ip":obj_str})]
        if isNetworkIp(obj_str):
            return ScopeView, [ScopeController(x) for x in Scope.fetchObjects({"scope":obj_str})]
        if isDomain(obj_str):
            return [ScopeView, IpView], [[ScopeController(x) for x in Scope.fetchObjects({"scope":obj_str})], [IpController(x) for x in Ip.fetchObjects({"ip":obj_str})]]
        #test for ip:port/Proto
        parts = obj_str.split(":")
        if len(parts) == 2 and (isIp(parts[0]) or isDomain(parts[0])):
            port_parts = parts[1].split("/")
            if len(port_parts) == 1:
                return PortView, [PortController(x) for x in Port.fetchObjects({"ip":parts[0], "port":port_parts[1], "proto":"tcp"})]
            else:
                return PortView, [PortController(x) for x in Port.fetchObjects({"ip":parts[0], "port":port_parts[1], "proto":port_parts[0]}) ]
        waves = [WaveController(x) for x in Wave.fetchObjects({"wave": obj_str})]
        if waves:
            return WaveView, waves
        commands = [CommandController(x) for x in Command.fetchObjects({"name":obj_str}, APIClient.getInstance().getCurrentPentest())]
        if commands:
            return CommandView, commands
        return None, []
    
    def cmd_default(self, *args):
        command = " ".join(list(args))
        ret = self.info(command, True)
        if ret == False:
            print_error(f"The given commmand '{command}' does not exist in this module.\nType 'help' to get the list of currently available commands\n")
                
    @command
    def info(self, object_title, called_by_default=False):
        """Usage: info <object_title>|commands|waves|scopes|ips

        Description: Show informations for the given object title:
        
        Arguments:
            object_title: a string to identify an object. or a class of objects as a plural
            * commands|waves|scopes|ips : equivalent to ls call
            * Scope : a network ip as x.x.x.x/y or a domain. Add "<wave_name>:" in front of scope if  many waves registered it
            * Ip: An ip or a domain
            * Port: an ip:port[/proto]
            * Wave: a wave name
            * Command: a command name
        """
        if self.ls(object_title):
            return # Ls worked
        cls, objects_matching = self.identifyPentestObjectsFromString(object_title)
        if isinstance(cls, list):
            for classe_i, classe in enumerate(cls):
                classe.print_info(objects_matching[classe_i])
        elif cls is not None:
            cls.print_info(objects_matching) 
        else:
            if not called_by_default:
                print_formatted(f"No info regarding {object_title}")
            return False
        return True

    @command
    def edit(self, object_title):
        """Usage: edit <object_title>

        Description: edit object module:
        
        Arguments:
            object_title: a string to identify an object.
            * Scope : a network ip as x.x.x.x/y or a domain. Add "<wave_name>:" in front of scope if  many waves registered it
            * Ip: An ip or a domain
            * Port: an ip:port[/proto]
            * Wave: a wave name
            * Command: a command name
        """
        # will swap context to edit an object and access it's subobjects
        cls, objects_matching = self.identifyPentestObjectsFromString(object_title)
        if isinstance(cls, list):
            print_formatted_text("Many objects founds:")
            for classe_i, classe in enumerate(cls):
                print_formatted_text(f"{classe_i+1}. {classe.name.capitalize()}")
            resp = None
            while resp is None:
                resp = prompt("which type do you want to edit ? (enter number)")
                try:
                    resp = int(resp)
                    if resp - 1 >= len(cls):
                        raise ValueError()
                except ValueError:
                    resp = None
            cls = cls[resp-1]
            objects_matching = objects_matching[resp-1]
        if cls is not None:
            if len(objects_matching) == 1:
                self.set_context(cls(objects_matching[0], self, self.prompt_session))
            else:
                cls.print_info(objects_matching)
        else:
            print_error(f"No object found matching this {object_title}")

    @command
    def insert(self, object_type):
        """Usage: insert commands|waves|ips

        Description: create a new object in database
        """
        apiclient = APIClient.getInstance()
        view = None
        if object_type == "commands":
            view = CommandView(CommandController(Command({"indb":apiclient.getCurrentPentest()})), self, self.prompt_session)
        elif object_type == "waves":
            view = WaveView(WaveController(Wave()), self, self.prompt_session)
        elif object_type == "ips":
            view = IpView(IpController(Ip()), self, self.prompt_session)
        else:
            print_error(f"{object_type} is not a valid top level object type to insert.")
        if view is not None:
            view.is_insert = True
            self.set_context(view)

    @command
    def query(self, search_query):
        """Usage: query <terms[ terms...]|tag_name>

        Description : Print a list of object title matching the query

        Arguments:
            search_query: A python like condition with:
                            - condition operators (==, !=, >, < , <=, >=, not in, in, regex) 
                            - boolean logic (and, or, not)
            Search examples in match (python condition):
            type == "port"
            type == "port" and port == 443
            type == "port" and port regex "443$"
            type == "port" and (port == 80 or port == 443)
            type == "port" and port != 443
            type == "port" and port != 443 and port != 80
            type == "defect"
            type == "defect" and "Foo" in title
            type == "ip" and ip regex "[A-Za-z]"
            type == "ip" and ip regex "^1\.2"
            type == "tool" and "done" in status
            type == "tool" and "done" not in status
            type == "tool" and "ready" in status
            type == "ip" and infos.key == "ABC" 
        """
        apiclient = APIClient.getInstance()
        settings = Settings()
        settings.reloadSettings()
        avail_tags = settings.getTags()
        if search_query in avail_tags:
            search_query = f"\"{search_query}\" == tags"
        results = apiclient.search(search_query)
        if results is not None:
            for types, documents in results.items():
                if types == "ports":
                    cls = PortView
                elif types == "defects":
                    cls = DefectView
                elif types == "commands":
                    cls = CommandView
                elif types == "waves":
                    cls = WaveView
                elif types == "scopes":
                    cls = ScopeView
                elif types == "ips":
                    cls = IpView
                elif types == "tools":
                    cls = ToolView
                else:
                    print_error("The given type is invalid : "+str(types))
                cls.print_info(documents)

        
    def getOptionsForCmd(self, cmd, cmd_args, complete_event):
        """Returns a list of valid options for the given cmd
        """  
        if cmd == "help":
            return [""]+self._cmd_list
        elif cmd == "ls":
            return ["commands", "waves", "scopes", "ips", "defects"]
        elif cmd == "insert":
            return ["commands", "waves", "scopes", "ips"]
        elif cmd == "info":
            return self.autoCompleteInfo(cmd_args, complete_event)
        elif cmd == "edit":
            return self.autoCompleteInfo(cmd_args, complete_event)
        elif cmd == "query":
            return self.autoCompleteQuery(cmd_args, complete_event)
        elif cmd == "upload":
            return self.autoCompleteUpload(cmd_args, complete_event)
        return []

    def autoCompleteUpload(self, cmd_args, complete_event):
        """
        Returns auto complete possibilites for the "upload" cmd
        Args:
            cmd_args: the current list of arguments given to info cmd (not completed)
            complete_event: the Completer event
        """
        apiclient = APIClient.getInstance()
        if len(cmd_args) == 1:
                return (Completion(completion.text, completion.start_position, display=completion.display) 
                            for completion in self.prompt_session.path_completer.get_completions(Document(cmd_args[0]), complete_event))
        
        elif len(cmd_args) == 2:
            plugins = apiclient.listPlugins()+["auto-detect"]
            ret = [x for x in plugins if x.startswith(cmd_args[1])]
            return ret
        return []
        

    def autoCompleteQuery(self, cmd_args, complete_event):
        """
        Returns auto complete possibilites for the "query" cmd
        Args:
            cmd_args: the current list of arguments given to info cmd (not completed)
            complete_event: the Completer event
        """
        if not cmd_args[0].startswith("'"):
            return ["'type == \"\"'"]
        return []

    def autoCompleteInfo(self, cmd_args, complete_event):
        """
        Returns auto complete possibilites for the "info" cmd
        Args:
            cmd_args: the current list of arguments given to info cmd (not completed)
            complete_event: the Completer event
        Returns:
            A list of suggestion for completion. 
            Starts by returning the object_titles if matches
            If letters are being typed, wave, commands and domain are tested
            if numbers are being typed, ip , port and scopes are tested
        object_title: a string to identify an object. or a class of objects as a plural
            * commands|waves|scopes|ips : equivalent to ls call
            * Scope : a network ip as x.x.x.x/y or a domain. Add "<wave_name>:" in front of scope if  many waves registered it
            * Ip: An ip or a domain
            * Port: an ip:port[/proto]
            * Wave: a wave name
            * Command: a command name
        """
        ls_objects = ["commands", "waves", "scopes", "ips", "defects"]
        toComplete = cmd_args[0]
        ret = []
        if len(toComplete) == 0:
            return ls_objects
        for ls_object in ls_objects:
            if ls_object.startswith(toComplete):
                ret.append(ls_object)
        parts = toComplete.split(":")
        if re.match(r"[0-9].*", toComplete):
            if len(parts) == 1: 
                # COMPLETE IP
                ret += [x.ip for x in Ip.fetchObjects({"ip":{"$regex":toComplete+".*"}})]
                # COMPLETE NETWORK IP (SCOPE) with no waves indicated
                ret += [x.scope for x in Scope.fetchObjects({"scope":{"$regex":toComplete+".*"}})]
                
            elif len(parts) == 2:
                if len(parts[1]) == "": # COMPLETE IP:PORT
                    ports = Port.fetchObjects({"ip":{"$regex":parts[0]+".*"}})
                    if ports is not None:
                        ret += [parts[0]+":"+x.port+"/"+x.proto for x in ports]
                else:
                    port_proto = parts[1].split("/")
                    if isIp(parts[0]):
                        try:
                            int(port_proto[1]) # check if int (port)
                            ret += [parts[0]+":"+x.port+"/"+x.proto for x in Port.fetchObjects({"ip":parts[0], "port":{"$regex":port_proto[1]+".*"}, "proto":{"$regex":+port_proto[0]+".*"}})]
                        except ValueError:
                            pass
        else:
            parts = toComplete.split(":")
            if len(parts) == 1:
                # COMPLETE WAVE
                ret += [x.wave for x in Wave.fetchObjects({"wave":{"$regex":toComplete+".*"}})]
                # COMPLETE COMMANDS
                ret += [x.name for x in Command.fetchObjects({"name":{"$regex":toComplete+".*"}})]
                # COMPLETE SCOPE (DOMAINS)
                ret += [x.scope for x in Scope.fetchObjects({"scope":{"$regex":toComplete+".*"}})]
            elif len(parts) == 2:
                # COMPLETE WAVE:SCOPE
                ret += [parts[0]+":"+x.scope for x in Scope.fetchObjects({"wave":parts[0], "scope":{"$regex":parts[1]+".*"}})]
        return ret