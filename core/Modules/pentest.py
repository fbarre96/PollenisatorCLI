import re

from core.apiclient import APIClient
from core.Controllers.CommandController import CommandController
from core.Controllers.IpController import IpController
from core.Controllers.PortController import PortController
from core.Controllers.ScopeController import ScopeController
from core.Controllers.WaveController import WaveController
from core.Models.Command import Command
from core.Models.Defect import Defect
from core.Models.Ip import Ip
from core.Models.Port import Port
from core.Models.Scope import Scope
from core.Models.Tool import Tool
from core.Models.Wave import Wave
from core.Modules.module import Module
from core.Views.CommandView import CommandView
from core.Views.IpView import IpView
from core.Views.PortView import PortView
from core.Views.ScopeView import ScopeView
from core.Views.ViewElement import ViewElement
from core.Views.WaveView import WaveView
from prompt_toolkit import HTML, print_formatted_text, prompt
from prompt_toolkit.completion import Completion
from prompt_toolkit.document import Document
from prompt_toolkit.shortcuts import ProgressBar
from utils.completer import IMCompleter
from utils.utils import (cls_commands, command, isDomain, isIp, isNetworkIp,
                         main_help, print_error, print_formatted)


@cls_commands
class Pentest(Module):
    def __init__(self, parent_context, prompt_session):
        super().__init__('Pentest', parent_context, "Pentesting mode.", 'Pentesting <placeholder>', IMCompleter(self), prompt_session)
        
    

    @command
    def reset_running_tools(self):
        """
        Usage : reset_running_tools
        Description : Reset all tools running to a ready state. This is useful if a command was running on a worker and the auto scanning was interrupted.
        """
        # test all the cases if datef is defined or not.
        # Normally, only the first one is necessary
        from core.Models.Tool import Tool
        tools = Tool.fetchObjects({"datef": "None", "scanner_ip": {"$ne": "None"}})
        for tool in tools:
            tool.markAsNotDone()
        tools = Tool.fetchObjects({"datef": "None", "dated": {"$ne": "None"}})
        for tool in tools:
            tool.markAsNotDone()
        tools = Tool.fetchObjects(
            {"datef": {"$exists": False}, "dated": {"$ne": "None"}})
        for tool in tools:
            tool.markAsNotDone()
        tools = Tool.fetchObjects(
            {"datef": {"$exists": False}, "scanner_ip": {"$ne": "None"}})
        for tool in tools:
            tool.markAsNotDone()
    
    
       


    @command
    def ls(self, object_type):
        """Usage: ls commands|waves|scopes|ips|defects

        Description: List all objects from the given type
        """
        apiclient = APIClient.getInstance()
        if object_type == "commands":
            commands = Command.fetchObjects({}, apiclient.getCurrentPentest())
            for command in commands:
                print_formatted_text(command.getDetailedString())
            return True
        elif object_type == "waves":
            waves = Wave.fetchObjects({})
            for wave in waves:
                print_formatted_text(wave.getDetailedString())
            return True
        elif object_type == "scopes":
            scopes = Scope.fetchObjects({})
            for scope in scopes:
                print_formatted_text(ViewElement.colorWithTags(scope.getTags(), scope.getDetailedString()))
            return True
        elif object_type == "ips":
            ips = Ip.fetchObjects({})
            for ip in ips:
                print_formatted_text(ViewElement.colorWithTags(ip.getTags(), ip.getDetailedString()))
            return True
        elif object_type == "defects":
            defects = Defect.fetchObjects({})
            for defect in defects:
                print_formatted_text(ViewElement.colorWithTags(defect.getTags(), defect.getDetailedString()))
            return True
        return False
    
    def identifyPentestObjectsFromString(self, obj_str):
        if isIp(obj_str):
            return IpView, [IpController(x) for x in Ip.fetchObjects({"ip":obj_str})]
        if isNetworkIp(obj_str):
            return ScopeView, [ScopeController(x) for x in Scope.fetchObjects({"scope":obj_str})]
        if isDomain(obj_str):
            return [ScopeView, IpView], [[ScopeController(x) for x in Scope.fetchObjects({"scope":obj_str})], [IpController(x) for x in Ip.fetchObjects({"ip":obj_str})]]
        #test for ip:port/Proto
        parts = obj_str.split(":")
        if len(parts) == 2 and (isIp(parts[0]) or isDomain(parts[0])):
            port_parts = parts[1].split("/")
            if len(port_parts) == 1:
                return PortView, [PortController(x) for x in Port.fetchObjects({"ip":parts[0], "port":port_parts[1], "proto":"tcp"})]
            else:
                return PortView, [PortController(x) for x in Port.fetchObjects({"ip":parts[0], "port":port_parts[1], "proto":port_parts[0]}) ]
        waves = [WaveController(x) for x in Wave.fetchObjects({"wave": obj_str})]
        if waves:
            return WaveView, waves
        commands = [CommandController(x) for x in Command.fetchObjects({"name":obj_str}, APIClient.getInstance().getCurrentPentest())]
        if commands:
            return CommandView, commands
        return None, []
    
    def cmd_default(self, *args):
        command = " ".join(list(args))
        ret = self.info(command, True)
        if ret == False:
            print_error(f"The given commmand '{command}' does not exist in this module.\nType 'help' to get the list of currently available commands\n")
                
    @command
    def info(self, object_title, called_by_default=False):
        """Usage: info <object_title>|commands|waves|scopes|ips

        Description: Show informations for the given object title:
        
        Arguments:
            object_title: a string to identify an object. or a class of objects as a plural
            * commands|waves|scopes|ips : equivalent to ls call
            * Scope : a network ip as x.x.x.x/y or a domain. Add "<wave_name>:" in front of scope if  many waves registered it
            * Ip: An ip or a domain
            * Port: an ip:port[/proto]
            * Wave: a wave name
            * Command: a command name
        """
        if self.ls(object_title):
            return #Â Ls worked
        cls, objects_matching = self.identifyPentestObjectsFromString(object_title)
        if isinstance(cls, list):
            for classe_i, classe in enumerate(cls):
                classe.print_info(objects_matching[classe_i])
        elif cls is not None:
            cls.print_info(objects_matching) 
        else:
            if not called_by_default:
                print_formatted(f"No info regarding {object_title}")
            return False
        return True

    @command
    def edit(self, object_title):
        """Usage: edit <object_title>

        Description: edit object module:
        
        Arguments:
            object_title: a string to identify an object.
            * Scope : a network ip as x.x.x.x/y or a domain. Add "<wave_name>:" in front of scope if  many waves registered it
            * Ip: An ip or a domain
            * Port: an ip:port[/proto]
            * Wave: a wave name
            * Command: a command name
        """
        # will swap context to edit an object and access it's subobjects
        cls, objects_matching = self.identifyPentestObjectsFromString(object_title)
        if isinstance(cls, list):
            print_formatted_text("Many objects founds:")
            for classe_i, classe in enumerate(cls):
                print_formatted_text(f"{classe_i+1}. {classe.name.capitalize()}")
            resp = None
            while resp is None:
                resp = prompt("which type do you want to edit ? (enter number)")
                try:
                    resp = int(resp)
                    if resp - 1 >= len(cls):
                        raise ValueError()
                except ValueError:
                    resp = None
            cls = cls[resp-1]
            objects_matching = objects_matching[resp-1]
        if cls is not None:
            if len(objects_matching) == 1:
                self.set_context(cls(objects_matching[0], self, self.prompt_session))
            else:
                cls.print_info(objects_matching)
        else:
            print_error(f"No object found matching this {object_title}")

    @command
    def insert(self, object_type):
        """Usage: insert commands|waves|ips

        Description: create a new object in database
        """
        apiclient = APIClient.getInstance()
        view = None
        if object_type == "commands":
            view = CommandView(CommandController(Command({"indb":apiclient.getCurrentPentest()})), self, self.prompt_session)
        elif object_type == "waves":
            view = WaveView(WaveController(Wave()), self, self.prompt_session)
        elif object_type == "ips":
            view = IpView(IpController(Ip()), self, self.prompt_session)
        else:
            print_error(f"{object_type} is not a valid top level object type to insert.")
        if view is not None:
            view.is_insert = True
            self.set_context(view)

   

        
    def getOptionsForCmd(self, cmd, cmd_args, complete_event):
        """Returns a list of valid options for the given cmd
        """  
        if cmd == "help":
            return [""]+self._cmd_list
        elif cmd == "ls":
            return ["commands", "waves", "scopes", "ips", "defects"]
        elif cmd == "insert":
            return ["commands", "waves", "scopes", "ips"]
        elif cmd == "info":
            return self.autoCompleteInfo(cmd_args, complete_event)
        elif cmd == "edit":
            return self.autoCompleteInfo(cmd_args, complete_event)
        elif cmd == "query":
            return self.autoCompleteQuery(cmd_args, complete_event)
        elif cmd == "upload":
            return self.autoCompleteUpload(cmd_args, complete_event)
        return []

    def autoCompleteUpload(self, cmd_args, complete_event):
        """
        Returns auto complete possibilites for the "upload" cmd
        Args:
            cmd_args: the current list of arguments given to info cmd (not completed)
            complete_event: the Completer event
        """
        apiclient = APIClient.getInstance()
        if len(cmd_args) == 1:
                return (Completion(completion.text, completion.start_position, display=completion.display) 
                            for completion in self.prompt_session.path_completer.get_completions(Document(cmd_args[0]), complete_event))
        
        elif len(cmd_args) == 2:
            plugins = apiclient.listPlugins()+["auto-detect"]
            ret = [x for x in plugins if x.startswith(cmd_args[1])]
            return ret
        return []
        

    def autoCompleteQuery(self, cmd_args, complete_event):
        """
        Returns auto complete possibilites for the "query" cmd
        Args:
            cmd_args: the current list of arguments given to info cmd (not completed)
            complete_event: the Completer event
        """
        if not cmd_args[0].startswith("'"):
            return ["'type == \"\"'"]
        return []

    def autoCompleteInfo(self, cmd_args, complete_event):
        """
        Returns auto complete possibilites for the "info" cmd
        Args:
            cmd_args: the current list of arguments given to info cmd (not completed)
            complete_event: the Completer event
        Returns:
            A list of suggestion for completion. 
            Starts by returning the object_titles if matches
            If letters are being typed, wave, commands and domain are tested
            if numbers are being typed, ip , port and scopes are tested
        object_title: a string to identify an object. or a class of objects as a plural
            * commands|waves|scopes|ips : equivalent to ls call
            * Scope : a network ip as x.x.x.x/y or a domain. Add "<wave_name>:" in front of scope if  many waves registered it
            * Ip: An ip or a domain
            * Port: an ip:port[/proto]
            * Wave: a wave name
            * Command: a command name
        """
        ls_objects = ["commands", "waves", "scopes", "ips", "defects"]
        toComplete = cmd_args[0]
        ret = []
        if len(toComplete) == 0:
            return ls_objects
        for ls_object in ls_objects:
            if ls_object.startswith(toComplete):
                ret.append(ls_object)
        parts = toComplete.split(":")
        if re.match(r"[0-9].*", toComplete):
            if len(parts) == 1: 
                # COMPLETE IP
                ret += [x.ip for x in Ip.fetchObjects({"ip":{"$regex":toComplete+".*"}})]
                # COMPLETE NETWORK IP (SCOPE) with no waves indicated
                ret += [x.scope for x in Scope.fetchObjects({"scope":{"$regex":toComplete+".*"}})]
                
            elif len(parts) == 2:
                if len(parts[1]) == "": # COMPLETE IP:PORT
                    ports = Port.fetchObjects({"ip":{"$regex":parts[0]+".*"}})
                    if ports is not None:
                        ret += [parts[0]+":"+x.port+"/"+x.proto for x in ports]
                else:
                    port_proto = parts[1].split("/")
                    if isIp(parts[0]):
                        try:
                            int(port_proto[1]) # check if int (port)
                            ret += [parts[0]+":"+x.port+"/"+x.proto for x in Port.fetchObjects({"ip":parts[0], "port":{"$regex":port_proto[1]+".*"}, "proto":{"$regex":+port_proto[0]+".*"}})]
                        except ValueError:
                            pass
        else:
            parts = toComplete.split(":")
            if len(parts) == 1:
                # COMPLETE WAVE
                ret += [x.wave for x in Wave.fetchObjects({"wave":{"$regex":toComplete+".*"}})]
                # COMPLETE COMMANDS
                ret += [x.name for x in Command.fetchObjects({"name":{"$regex":toComplete+".*"}})]
                # COMPLETE SCOPE (DOMAINS)
                ret += [x.scope for x in Scope.fetchObjects({"scope":{"$regex":toComplete+".*"}})]
            elif len(parts) == 2:
                # COMPLETE WAVE:SCOPE
                ret += [parts[0]+":"+x.scope for x in Scope.fetchObjects({"wave":parts[0], "scope":{"$regex":parts[1]+".*"}})]
        return ret
