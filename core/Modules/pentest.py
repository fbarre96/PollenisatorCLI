from utils.utils import command, cls_commands, print_error
from utils.utils import main_help, isIp, isNetworkIp, isDomain
from utils.completer import IMCompleter
from core.Modules.module import Module
import re
from prompt_toolkit.formatted_text import FormattedText
from core.apiclient import APIClient
from core.Models.Command import Command
from core.Models.Wave import Wave
from core.Models.Scope import Scope
from core.Models.Ip import Ip
from core.Models.Port import Port
from core.Models.Defect import Defect
from core.Controllers.CommandController import CommandController
from core.Controllers.IpController import IpController
from core.Controllers.PortController import PortController
from core.Controllers.ScopeController import ScopeController
from core.Controllers.WaveController import WaveController

from core.Views.CommandView import CommandView
from core.Views.WaveView import WaveView
from core.Views.ScopeView import ScopeView
from core.Views.IpView import IpView
from core.Views.PortView import PortView
from core.Views.DefectView import DefectView
from core.Views.ToolView import ToolView
from core.Views.ViewElement import ViewElement

@cls_commands
class Pentest(Module):
    def __init__(self, parent_context, prompt_session):
        super().__init__('Pentest', parent_context, "Pentesting mode.", 'Pentesting <placeholder>', IMCompleter(self), prompt_session)
        #TODO add modules
        """Modules
        =========
        Commands
        Tags
        Dashboard
        Summary
        Scan
        Report
        Settings
        Terminal
        """

    @command
    def reset_running_tools(self):
        """
        Usage : reset_running_tools
        Description : Reset all tools running to a ready state. This is useful if a command was running on a worker and the auto scanning was interrupted.
        """
        # test all the cases if datef is defined or not.
        # Normally, only the first one is necessary
        from core.Models.Tool import Tool
        tools = Tool.fetchObjects({"datef": "None", "scanner_ip": {"$ne": "None"}})
        for tool in tools:
            tool.markAsNotDone()
        tools = Tool.fetchObjects({"datef": "None", "dated": {"$ne": "None"}})
        for tool in tools:
            tool.markAsNotDone()
        tools = Tool.fetchObjects(
            {"datef": {"$exists": False}, "dated": {"$ne": "None"}})
        for tool in tools:
            tool.markAsNotDone()
        tools = Tool.fetchObjects(
            {"datef": {"$exists": False}, "scanner_ip": {"$ne": "None"}})
        for tool in tools:
            tool.markAsNotDone()

    @command
    def ls(self, object_type):
        """Usage: ls commands|waves|scopes|ips|defects

        Description: List all objects from the given type
        """
        apiclient = APIClient.getInstance()
        if object_type == "commands":
            commands = Command.fetchObjects({}, apiclient.getCurrentPentest())
            for command in commands:
                print(command.getDetailedString())
            return True
        elif object_type == "waves":
            waves = Wave.fetchObjects({})
            for wave in waves:
                print(wave.getDetailedString())
            return True
        elif object_type == "scopes":
            scopes = Scope.fetchObjects({})
            for scope in scopes:
                print(ViewElement.colorWithTags(scope.getTags(), scope.getDetailedString()))
            return True
        elif object_type == "ips":
            ips = Ip.fetchObjects({})
            for ip in ips:
                print(ViewElement.colorWithTags(ip.getTags(), ip.getDetailedString()))
            return True
        elif object_type == "defects":
            defects = Defect.fetchObjects({})
            for defect in defects:
                print(ViewElement.colorWithTags(defect.getTags(), defect.getDetailedString()))
            return True
        return False
    
    def identifyPentestObjectsFromString(self, obj_str):
        if isIp(obj_str) or isDomain(obj_str):
            return IpView, [IpController(x) for x in Ip.fetchObjects({"ip":obj_str})]
        if isNetworkIp(obj_str) or isDomain(obj_str):
            return ScopeView, [ScopeController(x) for x in Scope.fetchObjects({"scope":obj_str})]
        #test for ip:port/Proto
        parts = obj_str.split(":")
        if len(parts) == 2 and (isIp(parts[0]) or isDomain(parts[0])):
            port_parts = parts[1].split("/")
            if len(port_parts) == 1:
                return PortView, [PortController(x) for x in Port.fetchObjects({"ip":parts[0], "port":port_parts[0], "proto":"tcp"})]
            else:
                return PortView, [PortController(x) for x in Port.fetchObject({"ip":parts[0], "port":port_parts[0], "proto":port_parts[1]}) ]
        waves = [WaveController(x) for x in Wave.fetchObjects({"wave": obj_str})]
        if waves:
            return WaveView, waves
        commands = [CommandController(x) for x in Command.fetchObjects({"name":obj_str}, APIClient.getInstance().getCurrentPentest())]
        if commands:
            return CommandView, commands
        return None, []
    
    def cmd_default(self, *args):
        command = " ".join(list(args))
        ret = self.info(command, True)
        if ret == False:
            print_error(f"The given commmand '{command}' does not exist in this module.\nType 'help' to get the list of currently available commands\n")
                
    @command
    def info(self, object_title, called_by_default=False):
        """Usage: info <object_title>|commands|waves|scopes|ips

        Description: Show informations for the given object title:
        
        Arguments:
            object_title: a string to identify an object. or a class of objects as a plural
            * commands|waves|scopes|ips : equivalent to ls call
            * Scope : a network ip as x.x.x.x/y or a domain. Add "<wave_name>:" in front of scope if  many waves registered it
            * Ip: An ip or a domain
            * Port: an ip:port[/proto]
            * Wave: a wave name
            * Command: a command name
        """
        if self.ls(object_title):
            return #Â Ls worked
        cls, objects_matching = self.identifyPentestObjectsFromString(object_title)
        if cls is not None:
            cls.print_info(objects_matching) 
        else:
            if not called_by_default:
                print(f"No info regarding {object_title}")
            return False
        return True

    @command
    def edit(self, object_title):
        """Usage: edit <object_title>

        Description: edit object module:
        
        Arguments:
            object_title: a string to identify an object.
            * Scope : a network ip as x.x.x.x/y or a domain. Add "<wave_name>:" in front of scope if  many waves registered it
            * Ip: An ip or a domain
            * Port: an ip:port[/proto]
            * Wave: a wave name
            * Command: a command name
        """
        # will swap context to edit an object and access it's subobjects
        cls, objects_matching = self.identifyPentestObjectsFromString(object_title)
        if cls is not None:
            if len(objects_matching) == 1:
                self.set_context(cls(objects_matching[0], self, self.prompt_session))
            else:
                cls.print_info(objects_matching)
        else:
            print_error(f"No object found matching this {object_title}")

    @command
    def insert(self, object_type):
        """Usage: insert commands|waves|ips

        Description: create a new object in database
        """
        apiclient = APIClient.getInstance()
        view = None
        if object_type == "commands":
            view = CommandView(CommandController(Command({"indb":apiclient.getCurrentPentest()})), self, self.prompt_session)
        elif object_type == "waves":
            view = WaveView(WaveController(Wave()), self, self.prompt_session)
        elif object_type == "ips":
            view = IpView(IpController(Ip()), self, self.prompt_session)
        else:
            print_error(f"{object_type} is not a valid top level object type to insert.")
        if view is not None:
            view.is_insert = True
            self.set_context(view)

    @command
    def query(self, search_query):
        """Usage: query terms[ terms...]

        Description : Print a list of object title matching the query

        Arguments:
            search_query: A python like condition with:
                            - condition operators (==, !=, >, < , <=, >=, not in, in, regex) 
                            - boolean logic (and, or, not)
            Search examples in match (python condition):
            type == "port"
            type == "port" and port == 443
            type == "port" and port regex "443$"
            type == "port" and (port == 80 or port == 443)
            type == "port" and port != 443
            type == "port" and port != 443 and port != 80
            type == "defect"
            type == "defect" and "Foo" in title
            type == "ip" and ip regex "[A-Za-z]"
            type == "ip" and ip regex "^1\.2"
            type == "tool" and "done" in status
            type == "tool" and "done" not in status
            type == "tool" and "ready" in status
            type == "ip" and infos.key == "ABC" 
        """
        apiclient = APIClient.getInstance()
        results = apiclient.search(search_query)
        if results is not None:
            for types, documents in results.items():
                if types == "ports":
                    cls = PortView
                elif types == "defects":
                    cls = DefectView
                elif types == "commands":
                    cls = CommandView
                elif types == "waves":
                    cls = WaveView
                elif types == "scopes":
                    cls = ScopeView
                elif types == "ips":
                    cls = IpView
                elif types == "tools":
                    cls = ToolView
                else:
                    print("The given is invalid : "+str(types))
                cls.print_info(documents)

        
    def getOptionsForCmd(self, cmd, cmd_args, complete_event):
        """Returns a list of valid options for the given cmd
        """  
        apiclient = APIClient.getInstance()
        if cmd == "help":
            return [""]+self._cmd_list
        elif cmd == "ls":
            return ["commands", "waves", "scopes", "ips", "defects"]
        elif cmd == "insert":
            return ["commands", "waves", "scopes", "ips"]
        elif cmd == "info":
            return self.autoCompleteInfo(cmd_args, complete_event)
        elif cmd == "edit":
            return self.autoCompleteInfo(cmd_args, complete_event)
        elif cmd == "query":
            return self.autoCompleteQuery(cmd_args, complete_event)
        return []


    def autoCompleteQuery(self, cmd_args, complete_event):
        """
        Returns auto complete possibilites for the "info" cmd
        Args:
            cmd_args: the current list of arguments given to info cmd (not completed)
            complete_event: the Completer event
        """
        if not cmd_args[0].startswith("'"):
            return ["'type == \"\"'"]
        

    def autoCompleteInfo(self, cmd_args, complete_event):
        """
        Returns auto complete possibilites for the "info" cmd
        Args:
            cmd_args: the current list of arguments given to info cmd (not completed)
            complete_event: the Completer event
        Returns:
            A list of suggestion for completion. 
            Starts by returning the object_titles if matches
            If letters are being typed, wave, commands and domain are tested
            if numbers are being typed, ip , port and scopes are tested
        object_title: a string to identify an object. or a class of objects as a plural
            * commands|waves|scopes|ips : equivalent to ls call
            * Scope : a network ip as x.x.x.x/y or a domain. Add "<wave_name>:" in front of scope if  many waves registered it
            * Ip: An ip or a domain
            * Port: an ip:port[/proto]
            * Wave: a wave name
            * Command: a command name
        """
        ls_objects = ["commands", "waves", "scopes", "ips", "defects"]
        toComplete = cmd_args[0]
        ret = []
        if len(toComplete) == 0:
            return ls_objects
        for ls_object in ls_objects:
            if ls_object.startswith(toComplete):
                ret.append(ls_object)
        parts = toComplete.split(":")
        if re.match(r"[0-9].*", toComplete):
            if len(parts) == 1: 
                # COMPLETE IP
                ret += [x.ip for x in Ip.fetchObjects({"ip":{"$regex":toComplete+".*"}})]
                # COMPLETE NETWORK IP (SCOPE) with no waves indicated
                ret += [x.scope for x in Scope.fetchObjects({"scope":{"$regex":toComplete+".*"}})]
                
            elif len(parts) == 2:
                if len(parts[1]) == "": # COMPLETE IP:PORT
                    ports = Port.fetchObjects({"ip":{"$regex":parts[0]+".*"}})
                    if ports is not None:
                        ret += [parts[0]+":"+x.port+"/"+x.proto for x in ports]
                else:
                    port_proto = parts[1].split("/")
                    if isIp(parts[0]):
                        try:
                            int(port_proto[0]) # check if int (port)
                            ret += [parts[0]+":"+x.port+"/"+x.proto for x in Port.fetchObjects({"ip":parts[0], "port":{"$regex":port_proto[0]+".*"}, "proto":{"$regex":+port_proto[1]+".*"}})]
                        except ValueError:
                            pass
        else:
            parts = toComplete.split(":")
            if len(parts) == 1:
                # COMPLETE WAVE
                ret += [x.wave for x in Wave.fetchObjects({"wave":{"$regex":toComplete+".*"}})]
                # COMPLETE COMMANDS
                ret += [x.name for x in Command.fetchObjects({"name":{"$regex":toComplete+".*"}})]
                # COMPLETE SCOPE (DOMAINS)
                ret += [x.scope for x in Scope.fetchObjects({"scope":{"$regex":toComplete+".*"}})]
            elif len(parts) == 2:
                # COMPLETE WAVE:SCOPE
                ret += [parts[0]+":"+x.scope for x in Scope.fetchObjects({"wave":parts[0], "scope":{"$regex":parts[1]+".*"}})]
        return ret