import re

from pollenisatorcli.core.apiclient import APIClient
from pollenisatorcli.core.Controllers.CommandController import CommandController
from pollenisatorcli.core.Controllers.IpController import IpController
from pollenisatorcli.core.Controllers.PortController import PortController
from pollenisatorcli.core.Controllers.ScopeController import ScopeController
from pollenisatorcli.core.Controllers.WaveController import WaveController
from pollenisatorcli.core.Models.Command import Command
from pollenisatorcli.core.Models.Defect import Defect
from pollenisatorcli.core.Models.Ip import Ip
from pollenisatorcli.core.Models.Port import Port
from pollenisatorcli.core.Models.Scope import Scope
from pollenisatorcli.core.Models.Tool import Tool
from pollenisatorcli.core.Models.Wave import Wave
from pollenisatorcli.core.Modules.GlobalModule import GlobalModule
from pollenisatorcli.core.Views.CommandView import CommandView
from pollenisatorcli.core.Views.IpView import IpView
from pollenisatorcli.core.Views.PortView import PortView
from pollenisatorcli.core.Views.ScopeView import ScopeView
from pollenisatorcli.core.Views.DefectView import DefectView
from pollenisatorcli.core.Views.ViewElement import ViewElement
from pollenisatorcli.core.Views.WaveView import WaveView
from pollenisatorcli.core.settings import Settings

from prompt_toolkit import HTML, print_formatted_text, prompt
from prompt_toolkit import ANSI
from prompt_toolkit.shortcuts import ProgressBar
from pollenisatorcli.utils.completer import IMCompleter
from pollenisatorcli.utils.utils import (cls_commands, command, isDomain, isIp, isNetworkIp,
                         main_help, print_error, print_formatted_text, print_formatted)

name = "Pentest" # Used in command decorator

@cls_commands
class Pentest(GlobalModule):
    def __init__(self, parent_context, prompt_session):
        super().__init__('Pentest', parent_context, "Pentesting mode.", 'Pentesting <placeholder>', IMCompleter(self), prompt_session)
        
    

    @command
    def reset_running_tools(self):
        """
        Usage: reset_running_tools
        Description : Reset all tools running to a ready state. This is useful if a command was running on a worker and the auto scanning was interrupted.
        """
        # test all the cases if datef is defined or not.
        # Normally, only the first one is necessary
        from pollenisatorcli.core.Models.Tool import Tool
        tools = Tool.fetchObjects({"datef": "None", "scanner_ip": {"$ne": "None"}})
        for tool in tools:
            tool.markAsNotDone()
        tools = Tool.fetchObjects({"datef": "None", "dated": {"$ne": "None"}})
        for tool in tools:
            tool.markAsNotDone()
        tools = Tool.fetchObjects(
            {"datef": {"$exists": False}, "dated": {"$ne": "None"}})
        for tool in tools:
            tool.markAsNotDone()
        tools = Tool.fetchObjects(
            {"datef": {"$exists": False}, "scanner_ip": {"$ne": "None"}})
        for tool in tools:
            tool.markAsNotDone()
    
    @command
    def ls(self, object_type):
        """Usage: ls commands|waves|scopes|ips|defects

        Description: List all objects for a given type
        """
        apiclient = APIClient.getInstance()
        if object_type == "commands":
            commands = Command.fetchObjects({}, apiclient.getCurrentPentest())
            CommandView.print_info(commands)
            return True
        elif object_type == "waves":
            waves = Wave.fetchObjects({})
            WaveView.print_info(waves)
            return True
        elif object_type == "scopes":
            scopes = Scope.fetchObjects({})
            ScopeView.print_info(scopes)
            return True
        elif object_type == "ips":
            # Ip.fetchObjects({}) + treatment take too long, use aggregate 
            ips = apiclient.aggregate("ips",[
                {
                    "$lookup":{ # JOIN with ports collections using common IP
                        "from": "ports",
                        "localField": "ip",
                        "foreignField": "ip",
                        "as": "ports"
                    }
                },
                {
                    "$lookup":{ # JOIN with defects collections using common IP
                        "from": "defects",
                        "localField": "ip",
                        "foreignField": "ip",
                        "as": "defects"
                    }
                },
                {
                    "$lookup":{ # JOIN with tools collections if tool is lvl ip and tool_ip == ip.ip
                        "from": "tools",
                        "as": "tools",
                        "let":{"tool_ip":"$ip", "lvl":"ip"},
                        "pipeline": [{"$match":{"$expr":{"$and":[{"$eq":["$ip","$$tool_ip"]}, {"$eq":["$lvl","$$lvl"]}]}}}]
                    }
                }
                ])
            IpView.print_info(ips, level_of_info="minimal", is_aggregated=True)
            return True
        elif object_type == "defects":
            defects = Defect.fetchObjects({})
            DefectView.print_info(defects)
            return True
        return False
    
    def identifyPentestObjectsFromString(self, obj_str):
        if isIp(obj_str):
            return IpView, [IpController(x) for x in Ip.fetchObjects({"ip":obj_str})]
        if isNetworkIp(obj_str):
            return ScopeView, [ScopeController(x) for x in Scope.fetchObjects({"scope":obj_str})]
        if isDomain(obj_str):
            return [ScopeView, IpView], [[ScopeController(x) for x in Scope.fetchObjects({"scope":obj_str})], [IpController(x) for x in Ip.fetchObjects({"ip":obj_str})]]
        #test for ip:port/Proto
        parts = obj_str.split(":")
        if len(parts) == 2 and (isIp(parts[0]) or isDomain(parts[0])):
            port_parts = parts[1].split("/")
            if len(port_parts) == 1:
                return PortView, [PortController(x) for x in Port.fetchObjects({"ip":parts[0], "port":parts[1], "proto":"tcp"})]
            else:
                return PortView, [PortController(x) for x in Port.fetchObjects({"ip":parts[0], "port":port_parts[1], "proto":port_parts[0]}) ]
        waves = [WaveController(x) for x in Wave.fetchObjects({"wave": obj_str})]
        if waves:
            return WaveView, waves
        commands = [CommandController(x) for x in Command.fetchObjects({"name":obj_str}, APIClient.getInstance().getCurrentPentest())]
        if commands:
            return CommandView, commands
        return None, []
    
    def cmd_default(self, *args):
        command = " ".join(list(args))
        ret = self.info(command, True)
        if ret == False:
            print_error(f"The given commmand '{command}' does not exist in this module.\nType 'help' to get the list of currently available commands\n")
                
    @command
    def info(self, object_title, called_by_default=False):
        """Usage: info <object_title>|commands|waves|scopes|ips

        Description: Show informations for the given object title:
        
        Arguments:
            object_title: a string to identify an object. or a class of objects as a plural
            * commands|waves|scopes|ips : equivalent to ls call
            * Scope : a network ip as x.x.x.x/y or a domain. Add "<wave_name>:" in front of scope if  many waves registered it
            * Ip: An ip or a domain
            * Port: an ip:port[/proto]
            * Wave: a wave name
            * Command: a command name
        """
        if self.ls(object_title):
            return #Â Ls worked
        cls, objects_matching = self.identifyPentestObjectsFromString(object_title)
        if isinstance(cls, list):
            for classe_i, classe in enumerate(cls):
                classe.print_info(objects_matching[classe_i])
                print_formatted("\n")
        elif cls is not None:
            cls.print_info(objects_matching) 
        else:
            if not called_by_default:
                print_formatted(f"No info regarding {object_title}")
            return False
        return True

    @command
    def edit(self, object_title, *args):
        """Usage: edit <object_title>

        Description: edit any pentest object
        
        Arguments:
            object_title: a string to identify an object.
            * Scope : a network ip as x.x.x.x/y or a domain. Add "<wave_name>:" in front of scope if  many waves registered it
            * Ip: An ip or a domain
            * Port: an ip:port[/proto]
            * Wave: a wave name
            * Command: a command name
        """
        if len(args) >= 1:
            object_title += " "+(" ".join(args))
        # will swap context to edit an object and access it's subobjects
        cls, objects_matching = self.identifyPentestObjectsFromString(object_title)
        if isinstance(cls, list):
            print_formatted_text("Many objects founds:")
            for classe_i, classe in enumerate(cls):
                print_formatted_text(f"{classe_i+1}. {classe.name.capitalize()}")
            resp = None
            while resp is None:
                resp = prompt("which type do you want to edit ? (enter number)")
                try:
                    resp = int(resp)
                    if resp - 1 >= len(cls):
                        raise ValueError()
                except ValueError:
                    resp = None
            cls = cls[resp-1]
            objects_matching = objects_matching[resp-1]
        if cls is not None:
            if len(objects_matching) == 1:
                self.set_context(cls(objects_matching[0], self, self.prompt_session))
            else:
                cls.print_info(objects_matching)
        else:
            print_error(f"No object found matching this {object_title}")

    @command
    def insert(self, object_type):
        """Usage: insert commands|waves|ips

        Description: create a new object in database
        """
        apiclient = APIClient.getInstance()
        view = None
        if object_type == "commands":
            view = CommandView(CommandController(Command({"indb":apiclient.getCurrentPentest()})), self, self.prompt_session)
        elif object_type == "waves":
            view = WaveView(WaveController(Wave()), self, self.prompt_session)
        elif object_type == "ips":
            view = IpView(IpController(Ip()), self, self.prompt_session)
        else:
            print_error(f"{object_type} is not a valid top level object type to insert.")
        if view is not None:
            view.is_insert = True
            self.set_context(view)

    def queryAPI(self, *args):
        """Take a pollenisator API query or a tag name and returns a list:
        Returns:
            dict with key = type and value = documents where:
                - type : a pollenisator object type in : ["ports", "defects","commands","waves","scopes","ips","tools"] 
                - documents : A list of document of this type
        """
        search_query = " ".join(args)
        apiclient = APIClient.getInstance()
        if apiclient.getCurrentPentest() is None:
            print_error("Use open to connect to a pentest first")
            return
        settings = Settings()
        settings.reloadSettings()
        avail_tags = settings.getTags()
        if search_query in avail_tags:
            search_query = f"\"{search_query}\" == tags"
        results = apiclient.search(search_query)
        return results     

    @command
    def select(self, *args):
        """Usage: select <terms[ terms...]|tag_name>

        Description : Select a list of object title matching the query to edit them after

        Arguments:
            search_query: A python like condition with:
                            - condition operators (==, !=, >, < , <=, >=, not in, in, regex) 
                            - boolean logic (and, or, not)
            Search examples in match (python condition):
            select todo
            select type == "port"
            select type == "port" and port == 443
            select type == "port" and port regex "443$"
            select type == "port" and (port == 80 or port == 443)
            select type == "port" and port != 443
            select type == "port" and port != 443 and port != 80
            select type == "defect"
            select type == "defect" and title regex "Foo"
            select type == "ip" and ip regex "[A-Za-z]"
            select type == "ip" and ip regex "^1\.2"
            select type == "tool" and "done" in status
            select type == "tool" and "done" not in status
            select type == "tool" and "ready" in status
            select type == "ip" and infos.key == "ABC" 
        """
        results = self.queryAPI(*args)
        if results is None:
            return
        from pollenisatorcli.core.Modules.MultiSelection import MultiSelection
        empty = True
        for result in results.values():
            if result:
                empty = False
                break
        if empty:
            print_formatted("Nothing matched this query.", "warning")
            return
        self.set_context(MultiSelection(results, self, self.prompt_session))


    def getOptionsForCmd(self, cmd, cmd_args, complete_event):
        """Returns a list of valid options for the given cmd
        """  
        if cmd == "help":
            return [""]+self.__class__._cmd_list
        elif cmd == "ls":
            return ["commands", "waves", "scopes", "ips", "defects"]
        elif cmd == "insert":
            return ["commands", "waves", "scopes", "ips"]
        elif cmd == "info":
            return self.autoCompleteInfo(cmd_args, complete_event)
        elif cmd == "edit":
            return self.autoCompleteInfo(cmd_args, complete_event)
        elif cmd == "select":
            return self.autoCompleteSelect(cmd_args, complete_event)
        return super().getOptionsForCmd(cmd, cmd_args, complete_event)        

    def autoCompleteSelect(self, cmd_args, complete_event):
        """
        Returns auto complete possibilites for the "select" cmd
        Args:
            cmd_args: the current list of arguments given to info cmd (not completed)
            complete_event: the Completer event
        """
        if not cmd_args[0].startswith("type"):
            return ["type == \"\""]
        return []

    def autoCompleteInfo(self, cmd_args, complete_event):
        """
        Returns auto complete possibilites for the "info" cmd
        Args:
            cmd_args: the current list of arguments given to info cmd (not completed)
            complete_event: the Completer event
        Returns:
            A list of suggestion for completion. 
            Starts by returning the object_titles if matches
            If letters are being typed, wave, commands and domain are tested
            if numbers are being typed, ip , port and scopes are tested
        object_title: a string to identify an object. or a class of objects as a plural
            * commands|waves|scopes|ips : equivalent to ls call
            * Scope : a network ip as x.x.x.x/y or a domain. Add "<wave_name>:" in front of scope if  many waves registered it
            * Ip: An ip or a domain
            * Port: an ip:port[/proto]
            * Wave: a wave name
            * Command: a command name
        """
        ls_objects = ["commands", "waves", "scopes", "ips", "defects"]
        toComplete = cmd_args[0]
        ret = []
        if len(toComplete) == 0:
            return ls_objects
        for ls_object in ls_objects:
            if ls_object.startswith(toComplete):
                ret.append(ls_object)
        parts = toComplete.split(":")
        if re.match(r"[0-9].*", toComplete):
            if len(parts) == 1: 
                # COMPLETE IP
                ret += [x.ip for x in Ip.fetchObjects({"ip":{"$regex":toComplete+".*"}})]
                # COMPLETE NETWORK IP (SCOPE) with no waves indicated
                ret += [x.scope for x in Scope.fetchObjects({"scope":{"$regex":toComplete+".*"}})]
                
            elif len(parts) == 2:
                if len(parts[1]) == "": # COMPLETE IP:PORT
                    ports = Port.fetchObjects({"ip":{"$regex":parts[0]+".*"}})
                    if ports is not None:
                        ret += [parts[0]+":"+x.port+"/"+x.proto for x in ports]
                else:
                    port_proto = parts[1].split("/")
                    if isIp(parts[0]):
                        try:
                            int(port_proto[1]) # check if int (port)
                            ret += [parts[0]+":"+x.port+"/"+x.proto for x in Port.fetchObjects({"ip":parts[0], "port":{"$regex":port_proto[1]+".*"}, "proto":{"$regex":+port_proto[0]+".*"}})]
                        except ValueError:
                            pass
        else:
            parts = toComplete.split(":")
            if len(parts) == 1:
                # COMPLETE WAVE
                ret += [x.wave for x in Wave.fetchObjects({"wave":{"$regex":toComplete+".*"}})]
                # COMPLETE COMMANDS
                ret += [x.name for x in Command.fetchObjects({"name":{"$regex":toComplete+".*"}})]
                # COMPLETE SCOPE (DOMAINS)
                ret += [x.scope for x in Scope.fetchObjects({"scope":{"$regex":toComplete+".*"}})]
            elif len(parts) == 2:
                # COMPLETE WAVE:SCOPE
                ret += [parts[0]+":"+x.scope for x in Scope.fetchObjects({"wave":parts[0], "scope":{"$regex":parts[1]+".*"}})]
        return ret
